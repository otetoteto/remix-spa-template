# テスト戦略

本プロジェクトではなるべくバグが入り込まないように、いくつかの異なる種類のテストを用意しています。
[testing trophy](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications) に影響を受けており、以下にそれぞれの実行方法などを記述します。

## Static (静的解析テスト)

書いたコードを実行することなくテストします。
具体的には型の不一致や、特定のルールに従っているかを確認します。本プロジェクトでは型チェックに TypeScript を使用し、特定のルールに従っているかのチェック (Lint) に [Biome](https://biomejs.dev/ja/) を使用します。

これらのチェックは開発中に自動で行われて、何かエラーがある場合は VSCode 上で該当箇所に赤い(もしくは黄色い)下線が表示されます。
また、プロジェクト内を一気にチェックするためのコマンドも用意しています。

```sh
# プロジェクト内のすべてのファイルに対して型チェックを行う
pnpm typecheck

# プロジェクト内のすべてのファイルに対して Lint を行う
pnpm lint

# プロジェクト内のすべてのファイルに対して Lint を行い、自動で修正できる箇所は修正する
pnpm fix
```

これらのチェックは後述する Git フックでも実行されるようにしているので、コミット前には必ず実行されることになります。(任意でチェックを外せるようにもしています。)

## Unit Test (単体テスト) / Integration Test (統合テスト)

コードを実際に実行することでテストします。
テストの実行にはテストランナーが必要で、本プロジェクトでは [vitest](https://vitest.dev/) を使用します。
testing trophy に従って Integration Test を重点的に書いていく方針としています。

テストファイルを作成する場合は、テスト対象のファイルの隣に置くようにします。

```txt
# Unit Test の場合
.
├── xxx.ts
└── xxx.test.tsx	-> テストファイル

# Integration Test の場合
.
├── route.tsx
└── route.test.tsx	-> テストファイル
```

### Unit Test (単体テスト)

Unit Test はコンポーネントに対してよりも、関数に対して行うことが多いかもしれません。
単一のコンポーネントに対してテストはあまり書かなくてもいいですが、共通的に使用するコンポーネントで状態が複雑なものに対しては、書くこともあると思います。（ある程度の複雑な状態を扱う必要が出てきた場合はライブラリの使用を検討してもいいかもしれません。）

### Integration Test (統合テスト)

Integration Test は基本的にページコンポーネントに対して行います。
`route.tsx` で定義しているコンポーネントを描画してそのページの振る舞いを検査するのが目的です。
ページの描画にはデータアクセスが必要ですが、API のモックに [msw](https://mswjs.io/) を使用します。

## E2E Test

本プロジェクトでは用意しないが、実施する場合は [Playwright](https://playwright.dev/) を使用することを推奨します。
また、バックエンドとの統合も必要のため、E2E 用のリポジトリを作成して、 FE/BE と分離した環境でテストを作成してもいいです。
